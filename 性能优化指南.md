# TenRun WebView 安卓应用性能优化指南

## 概述

本文档提供了优化 TenRun WebView 安卓应用性能和用户体验的方法和建议。通过实施这些优化措施，可以显著提升应用的加载速度、响应性和整体用户体验。

## WebView 性能优化

### 1. 启用硬件加速

在 `capacitor.config.json` 中确保已启用硬件加速：

```json
{
  "android": {
    "webView": {
      "allowHardwareAcceleration": true
    }
  }
}
```

### 2. 优化 WebView 设置

在 `android/app/src/main/java/com/tenrun/webview/MainActivity.java` 文件中添加以下优化设置：

```java
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    
    // 获取 WebView
    WebView webView = getBridge().getWebView();
    
    // 启用 DOM 存储
    webView.getSettings().setDomStorageEnabled(true);
    
    // 启用应用缓存
    webView.getSettings().setAppCacheEnabled(true);
    webView.getSettings().setAppCachePath(getApplicationContext().getCacheDir().getAbsolutePath());
    
    // 设置缓存模式
    webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);
    
    // 启用数据库存储
    webView.getSettings().setDatabaseEnabled(true);
    
    // 启用地理位置
    webView.getSettings().setGeolocationEnabled(true);
}
```

### 3. 实现预加载和预连接

在 `web/js/app.js` 中添加预加载和预连接功能：

```javascript
// 预加载常用网站
function preloadCommonSites() {
  const commonSites = ['https://www.baidu.com', 'https://www.qq.com'];
  
  commonSites.forEach(site => {
    const link = document.createElement('link');
    link.rel = 'preconnect';
    link.href = site;
    document.head.appendChild(link);
  });
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
  preloadCommonSites();
});
```

## 应用启动优化

### 1. 优化启动画面

在 `capacitor.config.json` 中配置启动画面：

```json
{
  "plugins": {
    "SplashScreen": {
      "launchShowDuration": 1500,
      "launchAutoHide": true,
      "backgroundColor": "#ffffff",
      "androidSplashResourceName": "splash",
      "androidScaleType": "CENTER_CROP",
      "showSpinner": false,
      "splashFullScreen": true,
      "splashImmersive": true
    }
  }
}
```

### 2. 创建自定义启动画面

1. 在 `android/app/src/main/res/drawable` 目录下创建 `splash.xml`：

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@color/white" />
    <item>
        <bitmap
            android:gravity="center"
            android:src="@drawable/splash_icon" />
    </item>
</layer-list>
```

2. 将应用图标复制到 `android/app/src/main/res/drawable` 目录并命名为 `splash_icon.png`

## 内存管理优化

### 1. 清理 WebView 缓存

在 `web/js/app.js` 中添加定期清理缓存的功能：

```javascript
// 定期清理 WebView 缓存
function setupCacheCleaner() {
  // 每小时清理一次缓存
  setInterval(() => {
    if (window.Capacitor && window.Capacitor.isNative) {
      // 使用 Capacitor 插件清理缓存
      window.Capacitor.Plugins.WebView.clearCache();
    }
  }, 3600000); // 1小时 = 3600000毫秒
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
  setupCacheCleaner();
});
```

### 2. 优化内存使用

在 `android/app/src/main/AndroidManifest.xml` 中添加：

```xml
<application
    android:largeHeap="true"
    android:hardwareAccelerated="true">
    <!-- 其他配置 -->
</application>
```

## 网络优化

### 1. 实现离线缓存

在 `web/js/app.js` 中添加离线缓存支持：

```javascript
// 检查并注册 Service Worker 用于离线缓存
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('ServiceWorker 注册成功:', registration.scope);
        })
        .catch(error => {
          console.log('ServiceWorker 注册失败:', error);
        });
    });
  }
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
  registerServiceWorker();
});
```

### 2. 创建 Service Worker

在 `web` 目录下创建 `service-worker.js`：

```javascript
const CACHE_NAME = 'tenrun-webview-cache-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/css/styles.css',
  '/js/app.js',
  '/js/renderer.js'
];

// 安装 Service Worker 并缓存资源
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        return cache.addAll(urlsToCache);
      })
  );
});

// 网络请求拦截
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // 如果找到缓存的响应，则返回缓存
        if (response) {
          return response;
        }
        
        // 否则发起网络请求
        return fetch(event.request).then(
          response => {
            // 检查响应是否有效
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }
            
            // 克隆响应（因为响应是流，只能使用一次）
            const responseToCache = response.clone();
            
            // 将响应添加到缓存
            caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, responseToCache);
              });
            
            return response;
          }
        );
      })
  );
});

// 清理旧缓存
self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

## 用户体验优化

### 1. 添加下拉刷新功能

在 `web/js/app.js` 中添加下拉刷新功能：

```javascript
// 实现下拉刷新功能
function setupPullToRefresh() {
  let startY;
  let distance;
  const threshold = 100; // 触发刷新的阈值
  const webview = document.getElementById('webview');
  const refreshIndicator = document.createElement('div');
  
  refreshIndicator.className = 'refresh-indicator';
  refreshIndicator.textContent = '下拉刷新';
  refreshIndicator.style.display = 'none';
  document.body.appendChild(refreshIndicator);
  
  document.addEventListener('touchstart', e => {
    startY = e.touches[0].pageY;
  }, { passive: true });
  
  document.addEventListener('touchmove', e => {
    const currentY = e.touches[0].pageY;
    distance = currentY - startY;
    
    // 只有在页面顶部且向下拉动时才显示刷新指示器
    if (document.scrollingElement.scrollTop === 0 && distance > 0) {
      refreshIndicator.style.display = 'block';
      refreshIndicator.style.transform = `translateY(${Math.min(distance / 2, threshold)}px)`;
      
      if (distance > threshold) {
        refreshIndicator.textContent = '释放刷新';
      } else {
        refreshIndicator.textContent = '下拉刷新';
      }
      
      e.preventDefault();
    }
  });
  
  document.addEventListener('touchend', e => {
    if (distance > threshold) {
      // 触发刷新
      refreshIndicator.textContent = '刷新中...';
      
      // 刷新当前页面
      if (webview && webview.src) {
        webview.src = webview.src;
      }
      
      // 1秒后隐藏刷新指示器
      setTimeout(() => {
        refreshIndicator.style.display = 'none';
        refreshIndicator.style.transform = 'translateY(0)';
      }, 1000);
    } else {
      // 未达到阈值，隐藏刷新指示器
      refreshIndicator.style.display = 'none';
      refreshIndicator.style.transform = 'translateY(0)';
    }
    
    distance = 0;
  });
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
  setupPullToRefresh();
});
```

### 2. 添加下拉刷新样式

在 `web/css/styles.css` 中添加：

```css
/* 下拉刷新指示器样式 */
.refresh-indicator {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 50px;
  background-color: #f5f5f5;
  color: #333;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 14px;
  z-index: 1000;
  transform: translateY(-100%);
  transition: transform 0.2s;
}
```

### 3. 添加手势导航

在 `web/js/app.js` 中添加手势导航功能：

```javascript
// 实现手势导航
function setupGestureNavigation() {
  let startX;
  let startTime;
  const threshold = 100; // 触发导航的阈值
  const timeThreshold = 300; // 时间阈值（毫秒）
  
  document.addEventListener('touchstart', e => {
    startX = e.touches[0].pageX;
    startTime = new Date().getTime();
  }, { passive: true });
  
  document.addEventListener('touchend', e => {
    const endX = e.changedTouches[0].pageX;
    const endTime = new Date().getTime();
    const distance = endX - startX;
    const duration = endTime - startTime;
    
    // 检查是否是快速滑动手势
    if (duration < timeThreshold) {
      // 从左向右滑动（后退）
      if (distance > threshold) {
        goBack();
      }
      // 从右向左滑动（前进）
      else if (distance < -threshold) {
        goForward();
      }
    }
  }, { passive: true });
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
  setupGestureNavigation();
});
```

## 安全优化

### 1. 添加内容安全策略

在 `web/index.html` 的 `<head>` 中更新 CSP：

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: https://ssl.gstatic.com capacitor: 'unsafe-inline' 'unsafe-eval' https: http: ws:; style-src 'self' 'unsafe-inline'; media-src *; img-src 'self' data: content:;">
```

### 2. 实现安全的 WebView 配置

在 `android/app/src/main/java/com/tenrun/webview/MainActivity.java` 中添加安全配置：

```java
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    
    // 获取 WebView
    WebView webView = getBridge().getWebView();
    
    // 禁用文件访问
    webView.getSettings().setAllowFileAccess(false);
    webView.getSettings().setAllowFileAccessFromFileURLs(false);
    webView.getSettings().setAllowUniversalAccessFromFileURLs(false);
    
    // 禁用内容 URL 访问
    webView.getSettings().setAllowContentAccess(false);
    
    // 禁用保存表单数据
    webView.getSettings().setSaveFormData(false);
    
    // 设置安全的 WebViewClient
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            // 检查 URL 是否安全
            if (isUrlSafe(url)) {
                view.loadUrl(url);
                return true;
            }
            return false;
        }
        
        private boolean isUrlSafe(String url) {
            // 实现 URL 安全检查逻辑
            return url.startsWith("http://") || url.startsWith("https://");
        }
    });
}
```

## 总结

通过实施上述优化措施，可以显著提升 TenRun WebView 安卓应用的性能和用户体验。这些优化涵盖了以下几个方面：

1. **WebView 性能优化**：启用硬件加速、优化 WebView 设置、实现预加载和预连接
2. **应用启动优化**：优化启动画面、创建自定义启动画面
3. **内存管理优化**：清理 WebView 缓存、优化内存使用
4. **网络优化**：实现离线缓存、创建 Service Worker
5. **用户体验优化**：添加下拉刷新功能、添加手势导航
6. **安全优化**：添加内容安全策略、实现安全的 WebView 配置

根据应用的具体需求和用户反馈，可以选择性地实施这些优化措施，以提供更好的用户体验。